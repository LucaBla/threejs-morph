{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/BVHLoader.js"],
  "sourcesContent": ["import {\n\tAnimationClip,\n\tBone,\n\tFileLoader,\n\tLoader,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeleton,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.animateBonePositions = true;\n\t\tthis.animateBoneRotations = true;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\t/*\n\t\t\treads a string array (lines) from a BVH file\n\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\treturns thee root node:\n\t\t\t{ name: '', channels: [], children: [] }\n\t\t*/\n\t\tfunction readBvh( lines ) {\n\n\t\t\t// read model structure\n\n\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: HIERARCHY expected.' );\n\n\t\t\t}\n\n\t\t\tconst list = []; // collects flat array of all bones\n\t\t\tconst root = readNode( lines, nextLine( lines ), list );\n\n\t\t\t// read motion data\n\n\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: MOTION expected.' );\n\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tlet tokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst numFrames = parseInt( tokens[ 1 ] );\n\n\t\t\tif ( isNaN( numFrames ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read number of frames.' );\n\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\tconst frameTime = parseFloat( tokens[ 2 ] );\n\n\t\t\tif ( isNaN( frameTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read frame time.' );\n\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor ( let i = 0; i < numFrames; i ++ ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\treadFrameData( tokens, i * frameTime, root );\n\n\t\t\t}\n\n\t\t\treturn list;\n\n\t\t}\n\n\t\t/*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n\t\tfunction readFrameData( data, frameTime, bone ) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif ( bone.type === 'ENDSITE' ) return;\n\n\t\t\t// add keyframe\n\n\t\t\tconst keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new Vector3(),\n\t\t\t\trotation: new Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push( keyframe );\n\n\t\t\tconst quat = new Quaternion();\n\n\t\t\tconst vx = new Vector3( 1, 0, 0 );\n\t\t\tconst vy = new Vector3( 0, 1, 0 );\n\t\t\tconst vz = new Vector3( 0, 0, 1 );\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor ( let i = 0; i < bone.channels.length; i ++ ) {\n\n\t\t\t\tswitch ( bone.channels[ i ] ) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.BVHLoader: Invalid channel type.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor ( let i = 0; i < bone.children.length; i ++ ) {\n\n\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n\t\tfunction readNode( lines, firstline, list ) {\n\n\t\t\tconst node = { name: '', type: '', frames: [] };\n\t\t\tlist.push( node );\n\n\t\t\t// parse node type and name\n\n\t\t\tlet tokens = firstline.split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[ 1 ];\n\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\n\n\t\t\t}\n\n\t\t\tif ( nextLine( lines ) !== '{' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected opening { after type & name' );\n\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( tokens.length !== 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );\n\n\t\t\t}\n\n\t\t\tconst offset = new Vector3(\n\t\t\t\tparseFloat( tokens[ 1 ] ),\n\t\t\t\tparseFloat( tokens[ 2 ] ),\n\t\t\t\tparseFloat( tokens[ 3 ] )\n\t\t\t);\n\n\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );\n\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif ( node.type !== 'ENDSITE' ) {\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst numChannels = parseInt( tokens[ 1 ] );\n\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\n\t\t\t\tnode.children = [];\n\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tconst line = nextLine( lines );\n\n\t\t\t\tif ( line === '}' ) {\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n\t\tfunction toTHREEBone( source, list ) {\n\n\t\t\tconst bone = new Bone();\n\t\t\tlist.push( bone );\n\n\t\t\tbone.position.add( source.offset );\n\t\t\tbone.name = source.name;\n\n\t\t\tif ( source.type !== 'ENDSITE' ) {\n\n\t\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\t/*\n\t\t\tbuilds a AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: a AnimationClip containing position and quaternion tracks\n\t\t*/\n\t\tfunction toTHREEAnimation( bones ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\tconst bone = bones[ i ];\n\n\t\t\t\tif ( bone.type === 'ENDSITE' )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// track data\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst positions = [];\n\t\t\t\tconst rotations = [];\n\n\t\t\t\tfor ( let j = 0; j < bone.frames.length; j ++ ) {\n\n\t\t\t\t\tconst frame = bone.frames[ j ];\n\n\t\t\t\t\ttimes.push( frame.time );\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\n\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\n\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\n\n\t\t\t\t\trotations.push( frame.rotation.x );\n\t\t\t\t\trotations.push( frame.rotation.y );\n\t\t\t\t\trotations.push( frame.rotation.z );\n\t\t\t\t\trotations.push( frame.rotation.w );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBonePositions ) {\n\n\t\t\t\t\ttracks.push( new VectorKeyframeTrack( bone.name + '.position', times, positions ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.animateBoneRotations ) {\n\n\t\t\t\t\ttracks.push( new QuaternionKeyframeTrack( bone.name + '.quaternion', times, rotations ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( 'animation', - 1, tracks );\n\n\t\t}\n\n\t\t/*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n\t\tfunction nextLine( lines ) {\n\n\t\t\tlet line;\n\t\t\t// skip empty lines\n\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\n\n\t\t\treturn line;\n\n\t\t}\n\n\t\tconst scope = this;\n\n\t\tconst lines = text.split( /[\\r\\n]+/g );\n\n\t\tconst bones = readBvh( lines );\n\n\t\tconst threeBones = [];\n\t\ttoTHREEBone( bones[ 0 ], threeBones );\n\n\t\tconst threeClip = toTHREEAnimation( bones );\n\n\t\treturn {\n\t\t\tskeleton: new Skeleton( threeBones ),\n\t\t\tclip: threeClip\n\t\t};\n\n\t}\n\n}\n\nexport { BVHLoader };\n"],
  "mappings": "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",
  "names": ["lines", "bones"]
}
